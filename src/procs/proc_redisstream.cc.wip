/*
No copyright is claimed in the United States under Title 17, U.S. Code.
All Other Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#define PROC_NAME "redisstream"
//#define DEBUG 1

#include <cstdlib>
#include <cstdint>
#include <cstdio>
#include <unistd>
#include <cstring>

#include <memory>
#include <utility>
#include <algorithm>
#include <type_traits>
#include <iostream>
#include <cstdio>
#include <string>
#include <numeric>
#include <tuple>
#include <functional>

#include <hiredis/hiredis.h>
#include "waterslide.h"
#include "waterslidedata.h"
#include "datatypes/wsdt_tuple.h"
#include "datatypes/wsdt_uint.h"
#include "datatypes/wsdt_double.h"
#include "stringhash5.h"
#include "procloader.h"


extern "C" {
int proc_init(
    wskid_t * kid
  , int argc
  , char ** argv
  , void ** vinstance
  , ws_sourcev_t * sv
  , void * type_table
    );

proc_process_t proc_input_set(
    void * vinstance
  , wsdatatype_t * input_type
  , wslabel_t * port
  , ws_outlist_t* olist
  , int type_index
  , void * type_table
    );
int proc_destroy(
    void * vinstance
    );
}

extern "C" const char proc_name[]     =  PROC_NAME;
extern "C" const char proc_version[] =  "1.0";
extern "C" const char *proc_tags[]    =  {"Database", "Distributed", NULL};
extern "C" const char *proc_alias[]             =  { "hiredisstream", NULL };
extern "C" const char proc_purpose[]            =  "interact with redis database";
extern "C" const char proc_description[]  = "Interact with redis database including "
     "GET, SET, DELETE, SUBSCRIBE, PUBLISH, INCREMENT, and DECREMENT. "
     "This kid can act as a source for subscription events. One can use this "
     "kid for interacting with other stream processing, for distributed "
     "processing or for storing data into more permanent storage.";

extern "C" const proc_option_t proc_opts[]      =  {
     /*  'option character', "long option string", "option argument",
     "option description", <allow multiple>, <required>*/
     {'P',"","stream",
      "stream key to write events into.",0,0},
     {'K',"","stream key",
      "label containing the stream key to write events into.",0,0},
     {'T',"","sub tuple",
      "label of the sub tuple to emit to the stream.",0,0},
     {'h',"","hostname",
     "redis hostname (default to localhost)",0,0},
     {'p',""."port",
     "redis port (default to 6379)",0,0},
     {'m',"","maxlen",
      "maxlen parameter for XADD calls.",0,0},
     {'M',"","maxlen label",
      "label containing the value to use as maxlen.",0,0}
     //the following must be left as-is to signify the end of the array
     {' ',"","",
     "",0,0}
};

extern "C" const char proc_nonswitch_opts[]     =  "LABEL of key";
extern "C" const char *proc_input_types[]       =  {"tuple", NULL};
// (Potential) Output types: tuple
extern "C" const char *proc_output_types[]      =  {"tuple", NULL};
//char proc_requires[]           =  "";
// Ports: QUERYAPPEND
extern "C" const proc_port_t proc_input_ports[] =  {
     {"none","Emit the tuple to a redis stream"},
//     {"GET","Get value at key"},
//     {"SET","Set value at key"},
//     {"INCR","Increment value at key"},
//     {"DECR","Decrement value at key"},
//     {"PUBLISH","Publish value at specified channel"},
     {NULL, NULL}
};
//char *proc_tuple_container_labels[] =  {NULL};
//char *proc_tuple_conditional_container_labels[] =  {NULL};
char *proc_tuple_member_labels[] =  {"VALUE", NULL};
char *proc_synopsis[]          =  {"[PORT]:redisstream <LABEL> [-V VALUE] [-h hostname] [-p port]", NULL};
proc_example_t proc_examples[] =  {
     {"... | GET:redis WORD -L INFO | ...", "Queries redis server "
      "with the specified string in the WORD buffer; "
      "labels any result as INFO."},
     {"... | SET:redis WORD -V COUNT ", "Sets key and value in redis server "
      "with the specified key string in the WORD buffer and specified value "
      "string in COUNT buffer.; Has not output in this mode."},
     {"... | SET:redis WORD -V COUNT -x 5m ", "Sets key and value in redis server "
      "with the specified key string in the WORD buffer and specified value "
      "string in COUNT buffer; Value in redis is held for only 5 minutes."},
     {"... | INCR:redis WORD -L RESULT | ...", "Increments value at key in redis server "
      "using the specified key string in the WORD buffer; "
      "Resulting value after increment is labeled RESULT."},
     {"... | DECR:redis WORD -L RESULT | ...", "Decrements value at key in redis server "
      "using the specified key string in the WORD buffer;"
      "Resulting value after decrement is labeled RESULT."},
     {"... | PUBLISH:redis -P WordChannel VERB ADVERB | ...", "Publishes values in redis server "
      "using the channel named WordChannel using value strings found in VERB and ADVERB; "
      "input tuple is passed downstream as a passthrough operation."},
     {"redis -S SubChannel -h redishost -p 12345 -L REDISOUT | ...",
      "Subscribes to channel SubChannel in redis server found at host redishost and port 12345;"
      "Any output strings are labeled RESIDOUT; This acts as source kid that blocks waiting for input."},
    {NULL, NULL}
};

//function prototypes for local functions
/*static int proc_get(void *, wsdata_t*, ws_doutput_t*, int);
static int proc_set(void *, wsdata_t*, ws_doutput_t*, int);
static int proc_incr(void *, wsdata_t*, ws_doutput_t*, int);
static int proc_decr(void *, wsdata_t*, ws_doutput_t*, int);
static int proc_publish(void *, wsdata_t*, ws_doutput_t*, int);
static int proc_rsubscribe(void *, wsdata_t*, ws_doutput_t*, int);
*/
struct rc_del { void operator()(redisContext *rc){ if(rc) redisFree(rc);}};
using redis_ptr = std::unique_ptr<redisContext, rc_del>;
struct rr_del { void operator()(redisReplt *rr){ if(rr) freeReplyObject(rr);}};
using reply_ptr = std::unique_ptr<redisReply,rr_del>;;

struct proc_redisstream {
     uint64_t meta_process_cnt{};
     uint64_t outcnt{};

     std::string hostname{"localhost"};
     uint16_t port{6379u};
 
     wslabel_t * stream_label{"waterslide"};
     std::string stream_key  {};

     wslabel_t * maxlen_label{};
     uint64_t    maxlen      {};

     wslabel_set_t subtuple_lset{};
     wslabel_est_t element_lset {};

     
     redis_ptr rc{};

//   wslabel_nested_set_t nest_keys;
//   wslabel_nested_set_t nest_values;

     std::string stream_key{};
     time_t expire_sec{};

     wslabel_t * label_outvalue{};

     ws_outtype_t * outtype_tuple{};
     int cmd_process(int argc, char **argv,void *type_table);
     int proc_publish(wsdata_t * tuple,ws_doutput_t * dout, int type_index);

};

int proc_redisstream::cmd_options(int argc, char ** argv, void * type_table) {
     int op;
     while ((op = getopt(argc, argv, "P:K:T:h:p:m:M:")) != EOF) {
          switch (op) {
          case 'P':
               stream_key = std::string{optarg};
               tool_print("publishing to stream named %s", stream_key.c_str());
               break;
          case 'K':
               stream_label = wsregister_label(type_table,optarg);
               tool_print("publishing to stream found under label %s", stream_label->name);
               break;
          case 'S':
               wslabel_set_add(type_table, &subtuple_lset,optarg);
               tool_print("emitting the tuple found at %s", optarg);
               break;
          case 'm':
               maxlen = atoi(optarg);
               break;
          case 'M':
               maxlen_label = wsregister_label(type_table,optarg); 
               break;
          case 'h':
               hostname = std::string(optarg);
               break;
          case 'p':
               port = (uint16_t)atoi(optarg);
               break;
          default:
               return 0;
          }
     }
     while (optind < argc) {
          wslabel_set_add(type_table, &element_lset,argv[optind]);
          tool_print("using key %s", argv[optind]);
          optind++;
     }
     return 1;
}

// the following is a function to take in command arguments and initalize
// this processor's instance..
//  also register as a source here..
// return 1 if ok
// return 0 if fail
int proc_init(wskid_t * kid, int argc, char ** argv, void ** vinstance, ws_sourcev_t * sv,
              void * type_table) {
     
     //allocate proc instance of this processor
     auto proc = std::make_unique<proc_redisstream>();
     *vinstance = proc.get();

     //read in command options
     if (!proc->cmd_options(argc, argv, type_table))
          return 0;

    {
        struct timeval timeout = { 1, 500000 }; // 1.5 seconds
        auto c = redis_ptr(redisConnectWithTimeout(proc->hostname, proc->port, timeout));
        if (!c|| c->err) {
            if (c) {
                printf("Connection error: %s\n", c->errstr);
            } else {
                printf("Connection error: can't allocate redis context\n");
            }
            return 0;
        }
        proc->rc = std::move(c);
        dprint("got context");
    }
/*     if (proc->subscribe_channel) {
          proc->outtype_tuple =
               ws_register_source_byname(type_table,
                                         "TUPLE_TYPE", proc_rsubscribe, sv);
          if (proc->outtype_tuple ==NULL) {
               error_print("Error attempting to register source");
               return 0;
          }
          redisReply *reply =
               redisCommand(proc->rc, "SUBSCRIBE %s", proc->subscribe_channel);
          if (!reply) {
               error_print("unable to subscribe to channel %s",
                           proc->subscribe_channel);
               return 0;
          }
          freeReplyObject(reply);
     }*/
     proc.release();
     dprint("finished init");
     return 1; 
}

// this function needs to decide on processing function based on datatype
// given.. also set output types as needed (unless a sink)
//return 1 if ok
// return 0 if problem
proc_process_t proc_input_set(void * vinstance, wsdatatype_t * meta_type,
                              wslabel_t * port,
                              ws_outlist_t* olist, int type_index,
                              void * type_table) {
     auto proc = static_cast<proc_redisstream*>(vinstance);

     dprint("input_set");
     if (meta_type != dtype_tuple) {
          dprint("not tuple");
          return NULL;
     }
/*     if (!proc->outtype_tuple) {
          proc->outtype_tuple = ws_add_outtype(olist, dtype_tuple, NULL);
     }
*/
     return [](void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {
        return static_cast<proc_redisstream>(vinstance)->proc_xadd(
            tuple, dout, type_index);
     };
     return nullptr; // a function pointer
}

static int nest_search_callback_get(void * vproc, void * vevent,
                                    wsdata_t * tdata, wsdata_t * member) {
     dprint("key foundyy");
     proc_instance_t * proc = (proc_instance_t*)vproc;
     //search for member key
     char * buf = NULL;
     int len = 0;

     if (!dtype_string_buffer(member, &buf, &len)) {
          return 0;
     }
     redisReply *reply;

     dprint("query %.*s", len, buf);
     reply = redisCommand(proc->rc, "GET %b", buf, len);
     dprint("done...");
     if (reply) {
          dprint("reply succeeded");
          if ((reply->type == REDIS_REPLY_STRING) && reply->len && reply->str) {
               tuple_dupe_binary(tdata, proc->label_outvalue, reply->str, reply->len);
          }
          freeReplyObject(reply);
     }
     else {
          dprint("reply failed");
     }
     return 1;
}
int proc_redisstream::proc_xadd(wsdata_t *input_tuple,ws_doutput_t *dout, int type_idex)
{
    meta_process_cnt++;

    int id{};
    wsdata_t *member{};
    wslabel_t *label{};
    tuple_labelset_iter_t iter{};
    if(
    tuple_init_labelset_iter(&iter, input_data, 

}
//// proc processing function assigned to a specific data type in proc_io_init
//return 1 if output is available
// return 0 if not output
static int proc_get(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {

     dprint("proc_get");
     proc_instance_t * proc = (proc_instance_t*)vinstance;
     proc->meta_process_cnt++;

     dprint("search keys");
     tuple_nested_search(tuple, &proc->nest_keys,
                         nest_search_callback_get,
                         proc, NULL);
     
     ws_set_outdata(tuple, proc->outtype_tuple, dout);

     //always return 1 since we don't know if table will flush old data
     return 1;
}

static int proc_rsubscribe(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {
     
     proc_instance_t * proc = (proc_instance_t*)vinstance;
     redisReply *reply = NULL;

     dprint("attempting to get subscribe reply");
     if (redisGetReply(proc->rc,(void**)&reply) != REDIS_OK) {
          dprint("got invalid reply");
          return 1;
     }
     
     dprint("got reply %d", reply->type);
     if ((reply->type == REDIS_REPLY_STRING) && reply->len && reply->str) {
          dprint("got reply string");
          tuple_dupe_binary(tuple, proc->label_outvalue, reply->str, reply->len);
          ws_set_outdata(tuple, proc->outtype_tuple, dout);
     }
     else if (reply->type == REDIS_REPLY_ARRAY) {
          if (reply->elements == 3) {
               redisReply *r = reply->element[2];
               if ((r->type == REDIS_REPLY_STRING) && r->len && r->str) {
                    tuple_dupe_binary(tuple, proc->label_outvalue, r->str, r->len);
                    ws_set_outdata(tuple, proc->outtype_tuple, dout);
               }
          }
     }
     freeReplyObject(reply);
     return 1;
}

//select first element in search
static int nest_search_callback_one(void * vproc, void * vkey,
                                    wsdata_t * tdata, wsdata_t * member) {
     wsdata_t ** pkey = (wsdata_t**)vkey; 
     if (*pkey != NULL) {
          return 0;
     }
     *pkey = member;
     return 1;
}

static int proc_set(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {

     proc_instance_t * proc = (proc_instance_t*)vinstance;
     proc->meta_process_cnt++;

     wsdata_t * key = NULL;
     wsdata_t * value = NULL;

     tuple_nested_search(tuple, &proc->nest_keys,
                         nest_search_callback_one,
                         proc, &key);
     tuple_nested_search(tuple, &proc->nest_values,
                         nest_search_callback_one,
                         proc, &value);

     if (key && value) {
          dprint("found key and value");
          char * keybuf = NULL;
          int keylen = 0;
          char * valbuf = NULL;
          int vallen = 0;
          
          if (dtype_string_buffer(key, &keybuf, &keylen) && 
              dtype_string_buffer(value, &valbuf, &vallen)) {
               dprint("found key and value strings");

               redisReply *reply;

               if (proc->expire_sec) {
                    reply = redisCommand(proc->rc, "SET %b %b EX %d",
                                         keybuf, keylen, valbuf, vallen,
                                         (int)proc->expire_sec);
               }
               else {
                    dprint("setting %.*s %.*s", keylen, keybuf, vallen, valbuf);
                    reply = redisCommand(proc->rc, "SET %b %b",
                                         keybuf, keylen, valbuf, vallen);
               }
               if (reply) {
                    freeReplyObject(reply);
               }
          }
     }

     //always return 1 since we don't know if table will flush old data
     return 1;
}

static int nest_search_callback_incr(void * vproc, void * vevent,
                                    wsdata_t * tdata, wsdata_t * member) {
     proc_instance_t * proc = (proc_instance_t*)vproc;
     //search for member key
     char * buf = NULL;
     int len = 0;

     if (!dtype_string_buffer(member, &buf, &len)) {
          return 0;
     }
     redisReply *reply;

     reply = redisCommand(proc->rc, "INCR %b", buf, len);
     if (reply) {
          if (reply->type == REDIS_REPLY_INTEGER) {
               tuple_member_create_int(tdata, reply->integer, proc->label_outvalue);
          }
          freeReplyObject(reply);
     }
     return 1;
}

static int proc_incr(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {

     proc_instance_t * proc = (proc_instance_t*)vinstance;
     proc->meta_process_cnt++;

     tuple_nested_search(tuple, &proc->nest_keys,
                         nest_search_callback_incr,
                         proc, NULL);
     
     ws_set_outdata(tuple, proc->outtype_tuple, dout);

     //always return 1 since we don't know if table will flush old data
     return 1;
}

static int nest_search_callback_decr(void * vproc, void * vevent,
                                    wsdata_t * tdata, wsdata_t * member) {
     proc_instance_t * proc = (proc_instance_t*)vproc;
     //search for member key
     char * buf = NULL;
     int len = 0;

     if (!dtype_string_buffer(member, &buf, &len)) {
          return 0;
     }
     redisReply *reply;

     reply = redisCommand(proc->rc, "DECR %b", buf, len);
     if (reply) {
          if (reply->type == REDIS_REPLY_INTEGER) {
               tuple_member_create_int(tdata, reply->integer, proc->label_outvalue);
          }
          freeReplyObject(reply);
     }
     return 1;
}

static int proc_decr(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {

     proc_instance_t * proc = (proc_instance_t*)vinstance;
     proc->meta_process_cnt++;

     tuple_nested_search(tuple, &proc->nest_keys,
                         nest_search_callback_decr,
                         proc, NULL);
     
     ws_set_outdata(tuple, proc->outtype_tuple, dout);
     //always return 1 since we don't know if table will flush old data
     return 1;
}

static int nest_search_callback_publish(void * vproc, void * vevent,
                                    wsdata_t * tdata, wsdata_t * member) {
     dprint("got publish value");
     proc_instance_t * proc = (proc_instance_t*)vproc;
     //search for member key
     char * buf = NULL;
     int len = 0;

     if (!dtype_string_buffer(member, &buf, &len)) {
          return 0;
     }
     redisReply *reply;

     dprint("attempting to publish value");
     reply = redisCommand(proc->rc, "PUBLISH %s %b", proc->publish_channel, buf, len);
     if (reply) {
          dprint("success in publishing");
          freeReplyObject(reply);
     }
     return 1;
}


static int proc_publish(void * vinstance, wsdata_t * tuple,
                      ws_doutput_t * dout, int type_index) {

     proc_instance_t * proc = (proc_instance_t*)vinstance;
     proc->meta_process_cnt++;

     tuple_nested_search(tuple, &proc->nest_keys,
                         nest_search_callback_publish,
                         proc, NULL);
     tuple_nested_search(tuple, &proc->nest_values,
                         nest_search_callback_publish,
                         proc, NULL);
     
     ws_set_outdata(tuple, proc->outtype_tuple, dout);

     //always return 1 since we don't know if table will flush old data
     return 1;
}

//return 1 if successful
//return 0 if no..
int proc_destroy(void * vinstance) {
    delete static_cast<proc_redisstream*>(vinstance);
    return 1;
}


